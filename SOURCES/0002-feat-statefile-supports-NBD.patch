From c19ad819e83d9c73be731ec95b3b25b945b3f4f3 Mon Sep 17 00:00:00 2001
From: Ronan Abhamon <ronan.abhamon@vates.fr>
Date: Thu, 27 Jan 2022 19:43:07 +0100
Subject: [PATCH 2/2] feat(statefile): supports NBD

NBD is used to support LINSTOR SRs when we have more than 4 hosts,
in this case xha must use the O_DIRECT flag + O_SYNC with this device type because:
  - O_DIRECT is required to always have valid data (no cache on top of DRBD or other device).
  - The read and write delay before flush can be several tens of seconds without O_SYNC, this is not acceptable.

Signed-off-by: Ronan Abhamon <ronan.abhamon@vates.fr>
---
 lib/statefileio.c | 48 +++++++++++++++++++++++++++++++++++------------
 1 file changed, 36 insertions(+), 12 deletions(-)

diff --git a/lib/statefileio.c b/lib/statefileio.c
index 7360f56..e60b225 100755
--- a/lib/statefileio.c
+++ b/lib/statefileio.c
@@ -109,48 +109,72 @@ sf_FIST_delay_on_write();
 //
 
 
-extern int
-is_drbd_device(
+enum {
+    DEVICE_TYPE_NORMAL = 0,
+    DEVICE_TYPE_DRBD = 1,
+    DEVICE_TYPE_NBD = 2
+};
+
+static int
+get_device_type(
       const char *path)
 {
     static const int drbd_major = 147;
+    static const int nbd_major = 43;
 
     struct stat stats;
     if (stat(path, &stats) == -1)
     {
         log_internal(MTC_LOG_ERR, "SF: failed to execute stat (sys %d).\n", errno);
-        return 0;
+        return DEVICE_TYPE_NORMAL;
     }
-    return S_ISBLK(stats.st_mode) && major(stats.st_rdev) == drbd_major;
+    if (S_ISBLK(stats.st_mode))
+    {
+        const int dev_major = major(stats.st_rdev);
+        if (dev_major == drbd_major)
+            return DEVICE_TYPE_DRBD;
+        if (dev_major == nbd_major)
+            return DEVICE_TYPE_NBD;
+    }
+    return DEVICE_TYPE_NORMAL;
+}
+
+extern int
+is_drbd_device(
+      const char *path)
+{
+    return get_device_type(path) == DEVICE_TYPE_DRBD;
 }
 
 static int
 retry_open(
-  int is_drbd)
+  int device_type)
 {
-  return (errno == EROFS && is_drbd) || errno == EAGAIN;
+    return (errno == EROFS && device_type == DEVICE_TYPE_DRBD) || errno == EAGAIN || errno == EINTR;
 }
 
 extern int
 sf_open(
     char *path)
 {
-    int fd = open(path, (O_RDWR | O_DIRECT));
+    const int device_type = get_device_type(path);
+    const int flags = O_RDWR | O_DIRECT | (device_type == DEVICE_TYPE_NBD ? O_SYNC : 0);
+
+    int fd = open(path, flags);
     if (fd >= 0)
     {
       return fd;
     }
 
-    const int is_drbd = is_drbd_device(path);
-    if (retry_open(is_drbd))
+    if (retry_open(device_type))
     {
         int attempt;
         for (attempt = 0; attempt < OPEN_ATTEMPTS; ++attempt)
         {
-            log_internal(MTC_LOG_WARNING, "SF: failed to open the DRBD State-File %s (sys %d)... Retry: %d\n", path, errno, attempt);
+            log_internal(MTC_LOG_WARNING, "SF: failed to open State-File %s (sys %d)... Retry: %d\n", path, errno, attempt);
 
-            fd = open(path, (O_RDWR | O_DIRECT));
-            if (fd < 0 && retry_open(is_drbd))
+            fd = open(path, flags);
+            if (fd < 0 && retry_open(device_type))
             {
                 sf_sleep(OPEN_SLEEP_INTERVAL);
             }
-- 
2.36.0

