Support IPv6

Upstram PR: https://github.com/xenserver/xha/pull/11

- Replace `inet_addr` by `getaddrinfo`
- Replace `sockaddr_in` by `sockaddr_storage`

Signed-off-by: Ronan Abhamon <ronan.abhamon@vates.fr>
Co-authored-by: Benjamin Reis <benjamin.reis@vates.fr>

diff --git a/daemon/heartbeat.c b/daemon/heartbeat.c
index c304587..a8d28ba 100755
--- a/daemon/heartbeat.c
+++ b/daemon/heartbeat.c
@@ -194,14 +194,14 @@ static struct {
 
 static struct {
     MTC_S32             socket;
-    struct sockaddr     sa_to[MAX_HOST_NUM];
+    socket_address      sa_to[MAX_HOST_NUM];
     WATCHDOG_HANDLE     watchdog;
     MTC_BOOLEAN         terminate;
     pthread_spinlock_t  lock;
     MTC_U32             sequence[MAX_HOST_NUM];
 } hbvar = {
     .socket = -1,
-    .sa_to = {{0}},
+    .sa_to = {},
     .watchdog = INVALID_WATCHDOG_HANDLE_VALUE,
     .terminate = FALSE,
     .sequence = {0},
@@ -453,14 +453,29 @@ hb_initialize0()
 
     // open & bind socket
     {
-        struct sockaddr_in  sa;
-
-        memset(&sa, 0, sizeof(sa));
-        sa.sin_family = AF_INET;
-        sa.sin_port = htons(_udp_port);
-        sa.sin_addr.s_addr = _host_info[_my_index].ip_address;
+        size_t sock_len = 0;
+        socket_address *ss = &_host_info[_my_index].sock_address;
+        switch (ss->sa.sa_family)
+        {
+            case AF_INET: {
+                struct sockaddr_in *sa = &ss->sa_in;
+                sa->sin_port = htons(_udp_port);
+                sock_len = sizeof *sa;
+                break;
+            }
+            case AF_INET6: {
+                struct sockaddr_in6 *sa6 = &ss->sa_in6;
+                sa6->sin6_port = htons(_udp_port);
+                sock_len = sizeof *sa6;
+                break;
+            }
+            default:
+                log_internal(MTC_LOG_ERR, "HB: Cannot create socket, invalid socket family (%d).\n", ss->sa.sa_family);
+                ret = MTC_ERROR_HB_SOCKET;
+                goto error;
+        }
 
-        hbvar.socket = socket(PF_INET, SOCK_DGRAM, 0);
+        hbvar.socket = socket(ss->sa.sa_family, SOCK_DGRAM, 0);
         if (hbvar.socket < 0)
         {
             log_internal(MTC_LOG_ERR, "HB: cannot create socket. (sys %d)\n", errno);
@@ -476,11 +491,23 @@ hb_initialize0()
             ret = MTC_ERROR_HB_SOCKET;
             goto error;
         }
-        if (bind(hbvar.socket, (struct sockaddr *) &sa, sizeof(sa)))
+        if (bind(hbvar.socket, &ss->sa, sock_len))
         {
-            log_internal(MTC_LOG_ERR,
-                "HB: cannot bind socket address (IP address = %s:%d). (sys %d)\n",
-                inet_ntoa(sa.sin_addr), _udp_port, errno);
+            const int error = errno;
+            char ip_address[INET6_ADDRSTRLEN];
+            if (inet_ntop(ss->sa.sa_family, ss, ip_address, sizeof ip_address))
+            {
+                log_internal(MTC_LOG_ERR,
+                   "HB: cannot bind socket address (IP address = %s:%d). (sys %d)\n",
+                   ip_address, _udp_port, error);
+            }
+            else
+            {
+                log_internal(MTC_LOG_ERR,
+                   "HB: cannot bind socket address (unable to get IP address). (sys %d)\n",
+                   error);
+            }
+
             ret = MTC_ERROR_HB_SOCKET;
             goto error;
         }
@@ -492,11 +519,30 @@ hb_initialize0()
 
         for (index = 0; _is_configured_host(index); index++)
         {
+            socket_address *ss = &_host_info[index].sock_address;
+
             memset(&hbvar.sa_to[index], 0, sizeof(hbvar.sa_to[index]));
-            ((struct sockaddr_in *) &(hbvar.sa_to[index]))->sin_family = AF_INET;
-            ((struct sockaddr_in *) &(hbvar.sa_to[index]))->sin_port = htons(_udp_port);
-            ((struct sockaddr_in *) &(hbvar.sa_to[index]))->sin_addr.s_addr =
-                                                _host_info[index].ip_address;
+            switch (ss->sa.sa_family)
+            {
+                case AF_INET: {
+                    struct sockaddr_in *sa = &hbvar.sa_to[index].sa_in;
+                    sa->sin_family = AF_INET;
+                    sa->sin_port = htons(_udp_port);
+                    sa->sin_addr.s_addr = ss->sa_in.sin_addr.s_addr;
+                    break;
+                }
+                case AF_INET6: {
+                    struct sockaddr_in6 *sa6 = &hbvar.sa_to[index].sa_in6;
+                    sa6->sin6_family = AF_INET6;
+                    sa6->sin6_port = htons(_udp_port);
+                    memcpy(&sa6->sin6_addr.s6_addr, ss->sa_in6.sin6_addr.s6_addr, sizeof sa6->sin6_addr.s6_addr);
+                    break;
+                }
+                default:
+                    assert(FALSE); // Already checked during config parsing.
+                    ret = MTC_ERROR_HB_SOCKET;
+                    goto error;
+            }
         }
     }
 
@@ -992,12 +1038,18 @@ send_hb()
     if (!hb_check_fist("hb.isolate") &&
         !fist_on("hb.send.lostpacket"))
     {
+        const socket_address *ss = &hbvar.sa_to[index];
+        const socklen_t dest_len = ss->sa.sa_family == AF_INET ? sizeof(ss->sa_in) : sizeof(ss->sa_in6);
+
         for (index = 0; _is_configured_host(index); index++)
         {
             if (index != _my_index)
             {
-                sendto(hbvar.socket, &pkt, sizeof(pkt), 0,
-                       &hbvar.sa_to[index], sizeof(hbvar.sa_to[index]));
+                const int ret = sendto(hbvar.socket, &pkt, sizeof(pkt), 0, &hbvar.sa_to[index].sa, dest_len);
+                if (ret == -1)
+                {
+                    log_message(MTC_LOG_ERR, "HB: sendto() failed. (sys %d)\n", errno);
+                }
             }
         }
     }
@@ -1037,12 +1089,12 @@ receive_hb()
 
     // Receiving a packet
     {
-        struct sockaddr_in  from;
-        socklen_t           len = sizeof(from);
-        MTC_S32             recvd;
+        socket_address  from;
+        socklen_t       len = sizeof(from);
+        MTC_S32         recvd;
 
         recvd = recvfrom(hbvar.socket, &pkt, sizeof(pkt), MSG_DONTWAIT,
-                         (struct sockaddr *) &from, &len);
+                         &from.sa, &len);
         if (recvd < 0 && errno == EAGAIN)
         {
             // Linux may returns EAGAIN even if the socket is selected.
@@ -1097,9 +1149,26 @@ receive_hb()
                 invalid_packet_recvd = TRUE;
                 time_invalid_packet_recvd = now;
 
+                char ip_address[INET6_ADDRSTRLEN] = "<invalid_ip>";
+                const int family = from.sa.sa_family;
+                inet_ntop(family, &from, ip_address, sizeof ip_address);
+
+                uint16_t port = 0;
+                switch (family)
+                {
+                case AF_INET:
+                    port = ntohs(from.sa_in.sin_port);
+                    break;
+                case AF_INET6:
+                    port = ntohs(from.sa_in6.sin6_port);
+                    break;
+                default:
+                    break; // Ignore...
+                }
+
                 log_message(MTC_LOG_WARNING,
                     "HB: invalid packet received from (%s:%d).\n",
-                    inet_ntoa(from.sin_addr), ntohs(from.sin_port));
+                    ip_address, port);
                 maskable_dump(DUMPPACKET, (PMTC_S8) &pkt, recvd);
             }
 
diff --git a/include/config.h b/include/config.h
index 334d33e..b090c93 100755
--- a/include/config.h
+++ b/include/config.h
@@ -34,8 +34,10 @@
 //
 //   
 
+#include <netdb.h>
 #include <netinet/in.h>
 #include <linux/limits.h>
+
 #include "mtctypes.h"
 #include "xha.h"
 
@@ -79,9 +81,15 @@
 //  Define the host identifier.
 //
 
+typedef union socket_address {
+    struct sockaddr sa;
+    struct sockaddr_in sa_in;
+    struct sockaddr_in6 sa_in6;
+} socket_address;
+
 typedef struct ha_config_host_info {
     MTC_S8  host_id[MTC_UUID_SIZE];  // '-' is removed,non NULL terminated.
-    in_addr_t ip_address;       // 
+    socket_address sock_address;
 } HA_CONFIG_HOST_INFO, *PHA_CONFIG_HOST_INFO;
 
 //
diff --git a/lib/config.c b/lib/config.c
index 0d8d57b..506e963 100755
--- a/lib/config.c
+++ b/lib/config.c
@@ -42,6 +42,7 @@
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
+#include <errno.h>
 #include <libxml2/libxml/xmlmemory.h>
 #include <libxml2/libxml/parser.h>
 
@@ -428,14 +429,54 @@ walk_host_config(
                 log_internal(MTC_LOG_ERR, "%s: failed to get IPaddress\n", __func__);
                 return MTC_ERROR_CF_INVALID_FORMAT;
             }
-            c->common.host[c->common.hostnum].ip_address = inet_addr((char *) txt);
-            if (c->common.host[c->common.hostnum].ip_address == 0) 
+
+            const char *ip_address = (char *) txt;
+
+            struct addrinfo hints;
+            struct addrinfo *result;
+            memset(&hints, 0, sizeof hints);
+            hints.ai_family = AF_UNSPEC;
+            hints.ai_socktype = SOCK_DGRAM;
+            hints.ai_flags = AI_NUMERICHOST;
+            hints.ai_protocol = 0;
+            hints.ai_canonname = NULL;
+            hints.ai_addr = NULL;
+            hints.ai_next = NULL;
+
+            errno = 0;
+            const int ret = getaddrinfo(ip_address, NULL, &hints, &result);
+            if (ret)
             {
-                log_internal(MTC_LOG_ERR, "%s: invalid IPaddress %s\n", __func__, txt);
+                log_internal(MTC_LOG_ERR, "%s: failed to get addr info of `%s` (info: %s). (sys %d)\n",
+                    __func__, ip_address, gai_strerror(ret), errno);
                 xmlFree(txt);
                 return MTC_ERROR_CF_INVALID_FORMAT;
             }
+
             xmlFree(txt);
+
+            socket_address *ss = &c->common.host[c->common.hostnum].sock_address;
+            switch (result->ai_family)
+            {
+                case AF_INET: {
+                    struct sockaddr_in *sa = &ss->sa_in;
+                    memcpy(&sa->sin_addr, &((struct sockaddr_in *) result->ai_addr)->sin_addr, sizeof sa->sin_addr);
+                    sa->sin_family = AF_INET;
+                    break;
+                }
+                case AF_INET6: {
+                    struct sockaddr_in6 *sa6 = &ss->sa_in6;
+                    memcpy(&sa6->sin6_addr, &((struct sockaddr_in6 *) result->ai_addr)->sin6_addr, sizeof sa6->sin6_addr);
+                    sa6->sin6_family = AF_INET6;
+                    break;
+                }
+                default:
+                    log_internal(MTC_LOG_ERR, "%s: Unsupported address type: %d\n", __func__, result->ai_family);
+                    freeaddrinfo(result);
+                    return MTC_ERROR_CF_INVALID_FORMAT;
+            }
+
+            freeaddrinfo(result);
         }
     }
     c->common.hostnum++;
